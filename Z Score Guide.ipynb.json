{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#FINDING A BASIC Z SCORE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 1: Define Z score function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def z(x,mu,sigma):\n",
    "    return (x - mu) / sigma\n",
    "#This line never changes, since this will always be the function for a z score and we always use these three \n",
    "#variables to solve for z. x is your x coordinate, mu is your mean, and sigma is your standard deviation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 2: call z score function and input required numbers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "z(x,mu,sigma)     #this line executes the z function from about with said values for x, mu, and sigma\n",
    "\n",
    "#Example\n",
    "z(70,63.8,4.2)\n",
    "#the z score will be 1.476"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#PLOTTING Z SCORES, PERCENTAGES, AND OTHER IMPORTANT DATA UNDER A NORMAL CURVE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 1: Import the necessary libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import norm\n",
    "from scipy.stats import zscore\n",
    "#This will import all the necessary functions we will need to call to complete the code"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 2: Set up an empty normal curve"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.arange(-4,4,0.01)    #This line sets x axis to start at -4, end at 4, by an interval auto generated by comp.\n",
    "plt.plot(x, norm.pdf(x))    #This line plots a standard normal curve"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 3: Create an array of z scores to fit your needs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "r = norm.rvs(size=number of values you want to take,loc=mean value,scale=standard deviation value)\n",
    "r\n",
    "#The 1st line creates an array and sets it equal to r. This array consists of however many values you set size equal\n",
    "#to. These values are based on the mean value and standard deviation you entered into the line. The second line, r,\n",
    "#calls the array to be displayed on the screen.\n",
    "\n",
    "#Example\n",
    "r = norm.rvs(size=20,loc=64,scale=4.2)     #This line gives us an array of 20 values from the curve based on a mean\n",
    "                                           #of 64 and a standard deviation of 4.2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 4: Get z scores for each value in the array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "zscore(r)     #This will give you an array of 20 z scores, each corresponding respectively to their values in the \n",
    "              #previous array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 5: Set the mean and standard deviation of new scores into variables"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rmean = np.mean(r)     #This line will find the mean of array \"r\" and store it in variable \"rmean\"\n",
    "rstd = np.std(r)       #This line will find the standard deviation of array \"r\" and store in in variable \"rstd\"\n",
    "print(rmean,rstd)      #This line will print the values assigned to \"rmean\" and \"rstd\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 6: ***THIS STEP IS AS NEEDED!*** Use various functions to find certain data points/info "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "z(r[2],rmean,rstd)     #This line will call the z score from the \"2\" position in the array\n",
    "\n",
    "p = norm.cdf(r[number],rmean,rstd)   #This line will calculate cumulative dist. function of the value @ the \"number\" \n",
    "p                                    #position in the array and store it in variable p. \n",
    "\n",
    "norm.cdf(value,rmean,rstd)     #This line will calculate the cumulative dist. function for the actual value inputed as\n",
    "                               #\"value\"\n",
    "\n",
    "z(value,rmean,rstd)     #This line will call the z score of the number entered as \"value\" under the curve defined as\n",
    "                        #rmean and rstd\n",
    "    \n",
    "norm.ppf(percentage as decimal)    #This line will take the user inputed percentage and return what x coordinate value\n",
    "                                   #this percentage occurs at on the normal curve"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Step 7: Plot desired data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.arange(first value on x axis,last value on x axis,interval)\n",
    "plt.plot(x,norm.pdf(x))\n",
    "xs = np.arange(leftmost value of shaded area,rightmost value of shaded area,interval)\n",
    "#This line establishes the area under the curve you want to shade. The first value is the coordinate value it starts\n",
    "#at on the x axis, the second value is the coordinate value where the shading ends on the x axis, and the last value \n",
    "#is the interval. use 0.01 for all intervals\n",
    "plt.fill_between(xs,norm.pdf(xs))    #this command plots the shaded area stipulated in the above line\n",
    "plt.ticks([leftmost value of shaded area,righmost values of shaded area],['leftmost value of shaded area',\n",
    "'rightmost value of shaded area'])\n",
    "#The first bracket in this line actually places the tick marks at the values established earlier. The second bracket\n",
    "#assigns the actual printed name of the ticks onto the plot\n",
    "\n",
    "#Example\n",
    "x = np.arange(first value on x axis,last value on x axis,interval)\n",
    "plt.plot(x,norm.pdf(x))\n",
    "xs = np.arange(.16,1.48,0)\n",
    "plt.fill_between(xs,norm.pdf(xs))\n",
    "plt.xticks([.16,1.48],['.16','1.48'])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
